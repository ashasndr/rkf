#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

#############################
################## GLOBALS
scheme=""
has_emojis=false
title=""
subtitle=""
lines=0
cols=""
has_display=false
has_display_less=false
has_copy=true
has_separators=true
has_windows=false
has_recover=false

#############################
################## FUNCTIONS
changelogs() {
    cat <<EOF
    2.2 - added recover save option, which recovers the temporary editing file
    2.1 - added disco genre, made et YYMM instead of MMYY, recoded so reasonings can have dashes and improved output (shuf | nl thing)
    2.0 - completely recoded everything, renamed to rkf, better error display, mcatalog support, full line copying support, the options people would "want" are now all enabled by default
    ---
    1.7 - added markers and numeration (first update in a hot minute too)
    1.6 - added windows compatibility through wsl
    1.5 - added emotes arg, nocopy arg, added display arg. added dash miniargs
    1.4 - renamed args norank to nork and ncsinfo to ninf, added title arg.
    1.3 - reformatted to clear code, having an certain order isn't needed in arguments anymore. added ncsinfo and import arg
    1.2 - added nanify
    1.1 - added order argument and help
    1.0 - created with regular formatting
EOF
    exit 0

}

usage() {
    cat <<EOF
Usage: rkf [options]

Options:
  -n            Use the NCS scheme
  -m            Use the Monstercat scheme
  -e            Use VNF (Vip NCS Fans Server) discord emojis for genres
  -r            Use the last saved file and continue editing it
  -s            Disable separators (-=-= :emoji: =-=-)
  -2            2 lines (Artists, Songs)
  -3            3 lines (Genre, Artists, Songs)
                if neither 2 or 3 are selected, it'll default to full document lines.
  -d            display (cat) after execution
  -l            display (less) after exec
  -c            DO NOT copy result after finished
  -w            Sets you to Windows (WSL) mode (but likely already auto-detects if you are on windows, only use if you are experiencing issues)

  --title "yourtext"        Set a title (Ranking (scheme) (yourtext))
        aka --ti
  --subtitle "yourtext"     Set the subtitle
        aka --sb
  --fulltitle "yourtext"    Set a title (yourtext)
        aka --ft
        aka --full
  --expresstitle MMYY       Set a title (Ranking (scheme) (MM converted to month) 20(YY))
        aka --et
  -h, --help                Show this help message
  --last                    Shows last output
  --err                     Shows last error
  --cperr                   Copies last error
  --cplast                  Copies last output
  --mcatalog                Copies MCatalog URL
  --monstercatplaylist      Copies Monstercat playlist URL
  --ncsinfo                 Copies NCS Info URL
  --ncsplaylist             Copies NCS playlist URL
  --changelog               Display changelogs
EOF
    exit "$1"
}

set_clipboard_cmds() {
    if command -v wl-copy >/dev/null 2>&1 && command -v wl-paste >/dev/null 2>&1; then
        clip_copy="wl-copy"
        clip_paste="wl-paste"
    elif command -v xclip >/dev/null 2>&1; then
        clip_copy="xclip -selection clipboard"
        clip_paste="xclip -selection clipboard -o"
    else
        echo "No wl-copy/wl-paste or xclip found in PATH" >&2
        return 1
    fi
}

display_debug() {
    echo "title     : $title"
    echo "subtitle  : $subtitle"
    echo "scheme    : $scheme"
    if $has_emojis; then
        echo "i contain emojis"
    else
        echo "i do not contain emojis"
    fi
    echo "lines     : $lines"
}

get_title() {
    echo "# Ranking ${scheme} ${1}"
}

unexpress_title() {
    local input=$1
    # grabs first 2 charas  prepend 20 directly
    local num_year="20${input:0:2}"
    # grabs the last 2 charas
    local num_month="${input: -2}"

    local month_name=""

    case "$num_month" in
        "01") month_name="January"      ;;
        "02") month_name="February"     ;;
        "03") month_name="March"        ;;
        "04") month_name="April"        ;;
        "05") month_name="May"          ;;
        "06") month_name="June"         ;;
        "07") month_name="July"         ;;
        "08") month_name="August"       ;;
        "09") month_name="September"    ;;
        "10") month_name="October"      ;;
        "11") month_name="November"     ;;
        "12") month_name="December"     ;;
    esac

    echo "# Ranking ${scheme} ${month_name} ${num_year}"
}

init_values() {
    if [[ $lines -eq 0 ]]; then
        if [[ $scheme == "Monstercat" ]]; then
            cols="5 6 7"
        elif [[ $scheme == "NCS" ]]; then
            cols="3 4 5"
        fi
    elif [[ $lines -eq 2 ]]; then
        cols="1 2"
    else
        cols="1 2 3"
    fi
}

lnend() {
    sed 's/\r//'
}

backtodos() {
    if [ $has_windows == true ]; then
        sed -i 's/$/\r/'
    else
        cat
    fi
}

##                                          gets expanded to empty if does not exist
if grep -qi microsoft /proc/version || [ -n "${WSL_DISTRO_NAME:-}" ]; then
    has_windows=true
fi

set_clipboard_cmds

#############################
################## FLAG PARSING
if [[ $# -eq 0 ]]; then
    usage 1
fi

while getopts ":23dlmenwhcrs-:" opt; do
    case $opt in
        n) scheme="NCS" ;;
        e) has_emojis=true ;;
        m) scheme="Monstercat" ;;
        2) lines=2 ;;
        3) lines=3 ;;
        c) has_copy=false ;;
        d) has_display=true ;;
        l) has_display_less=true ;;
        w) has_windows=true ;;
        s) has_separators=false ;;
        r) has_recover=true ;;
        h) usage 0 ;;
        -) # long options
            case $OPTARG in
                title|ti)
                    title=$(echo "# Ranking ${scheme} ${!OPTIND}")
                    OPTIND=$((OPTIND + 1))
                    ;;
                expresstitle|et)
                    title=$(unexpress_title ${!OPTIND})
                    OPTIND=$((OPTIND + 1))
                    ;;
                subtitle|sb)
                    subtitle=$(echo "-# ${!OPTIND}")
                    OPTIND=$((OPTIND + 1))
                    ;;
                fulltitle|full|ft)
                    title=$(echo "# ${!OPTIND}")
                    OPTIND=$((OPTIND + 1))
                    ;;
                help)
                    usage 0 ;;
                errors|err)
                    less errors.txt
                    exit 0
                    ;;
                copyerrors|cperr)
                    cat errors.txt | $clip_copy
                    exit 0
                    ;;
                last)
                    less rankoutput.txt
                    exit 0
                    ;;
                copylast|cplast)
                    cat rankoutput.txt | $clip_copy
                    exit 0
                    ;;
                mcatalog)
                    echo "https://docs.google.com/spreadsheets/d/116LycNEkWChmHmDK2HM2WV85fO3p3YTYDATpAthL8_g/edit" | $clip_copy
                    echo "https://docs.google.com/spreadsheets/d/116LycNEkWChmHmDK2HM2WV85fO3p3YTYDATpAthL8_g/edit"
                    exit 0
                    ;;
                ncsinfo)
                    echo "https://docs.google.com/spreadsheets/d/1XEPGiHCQ7thyRtyqei4yIuXaL-kXYQX-2bmx6ei99Is/edit?" | $clip_copy
                    echo "https://docs.google.com/spreadsheets/d/1XEPGiHCQ7thyRtyqei4yIuXaL-kXYQX-2bmx6ei99Is/edit?"
                    exit 0
                    ;;
                ncsplaylist)
                    echo "https://www.youtube.com/playlist?list=PLv1Kobfrv9Wtx2X6OG6pzg4ZEqNfsgCyW" | $clip_copy
                    echo "https://www.youtube.com/playlist?list=PLv1Kobfrv9Wtx2X6OG6pzg4ZEqNfsgCyW"
                    exit 0
                    ;;
                monstercatplaylist|mcatplaylist)
                    echo "https://www.youtube.com/playlist?list=PLv1Kobfrv9Wuo9JgSkVcoFTpBukYKmSvu" | $clip_copy
                    echo "https://www.youtube.com/playlist?list=PLv1Kobfrv9Wuo9JgSkVcoFTpBukYKmSvu"
                    exit 0
                    ;;
                changelogs|cglg)
                    changelogs
                    ;;
                *)
                    echo "Unknown flag: --$OPTARG" >&2
                    usage 1 ;;
            esac
            ;;
        \?)
            echo "Unknown flag: -$OPTARG" >&2
            usage 1 ;;
    esac
done
shift $((OPTIND - 1))

##########################
###### ERROR CHECKING
if [[ $scheme == "" ]]; then
    echo "Error: No scheme specified."
    usage 1
elif [[ $title = "" ]]; then
    echo "Error: No title specified"
    usage 1
elif [[ $has_emojis && $lines -eq 2 ]]; then
    echo "Cannot use emojis if you select only 2 columns"
fi

init_values

############
### TEXT SORTING FUNCTIONS

filter_out_ep() {
    if [ "$lines" -ne 2 ]; then
        grep -Ev '^(EP|Double Single|Album|Compilation)'
    else
        cat
    fi
}

parse_wanted_cols() {
    awk -v cols="$cols" -v FS='\t' -v OFS='\t' '{
        n = split(cols, a, " ")
        for (i=1; i<=n; i++) printf "%s%s", $a[i], (i<n ? OFS : ORS)
    }'
}
# reminder for future ash,  FS=field separator , OFS=output field separator, ORS=newline

emojify() {
    if [ "$has_emojis" ] && [ "$lines" -ne 2 ]; then
        awk -v FS='\t' -v OFS='\t' '
        function genre_of(genre) {
            if (genre ~ /Drum & Bass|Breaks|Neurofunk|Jump-Up/) return ":PinkCircle:"
            else if (genre ~ /Future House|Techno/) return ":PurpleCircle:"
            else if (genre ~ /Phonk|Brazilian Funk/) return ":TealCircle:"
            else if (genre ~ /Jersey Club|Hip Hop|Trap/) return ":GreenCircle:"
            else if (genre == "Future Bass") return ":LavenderCircle:"
            else if (genre ~ /Hardcore|Trance|Garage|Electronic|Hardstyle/) return ":WhiteCircle:"
            else if (genre == "Melodic Bass") return ":CyanCircle:"
            else if (genre ~ /Midtempo|Glitch Hop|Moombah/) return ":MintCircle:"
            else if (genre == "Melodic Dubstep") return ":CyanCircle:"
            else if (genre == "Dubstep") return ":BlueCircle:"
            else if (genre ~ /Pop|Synthwave|Synthpop|Traditional|Funk|Disco/) return ":OrangeCircle:"
            else if (genre == "Electro") return ":YellowCircle:"
            else if (genre == "Rock") return ":BlackCircle:"
            else if (genre ~ /Drumstep|Halftime/) return ":RedCircle:"
            else if (genre ~ /House$/ || genre == "Bass House") return ":YellowCircle:"
            else if (genre ~ /Chillout|Ambient|LoFi|Miscellaneous/) return ":WhiteCircle:"
            else return ":WhiteCircle:."
        }
        {
            if (NF == 3) {
                $1 = genre_of($1)
            }
            print
        }'
    else
        cat
    fi
}

format_into_song() {
    awk -v FS='\t' -v OFS=' ' '
    {
        for (i = 1; i <= NF; i++) {
            if (i < NF) {
                printf "%s%s", $i, OFS
            } else {
                printf "- %s | ", $i
            }
        }
        printf ORS
    }'
}

afterformat() {
    error_file="errors.txt"
    : > "$error_file"   # truncate errors

    shuf | nl -w1 -s$'\t' | \
    awk -F'\t|\\|' -v OFS='|' -v ERR="$error_file" '
    #   $1 = shuffle_index (int)
    #   $2 = song info text
    #   $3 = opinion
    {
        idx  = $1
        text = $2; sub(/[ \t]+$/, "", text)

        if (NF < 3) { print $0 > ERR; next }

        rest = $3

        if (match(rest, /^[ \t]*([0-9]+(\.[0-9])?)\/([0-9]+)[ \t]*-[ \t]*(.*)$/, m)) {
            rating    = m[1] + 0
            scale     = m[3] + 0
            reasoning = m[4]
            if (reasoning == "") reasoning = "no reasoning"
            if (scale != 10) { print $0 > ERR; next }
        } else {
            print $0 > ERR; next
        }

        printf "%s\t%06d\t**%s** | %s/%s - %s\n", rating, idx, text, rating, scale, reasoning
    }' \
    | sort -t $'\t' -k1,1nr -k2,2n \
    | cut -f3- \
    | nl -w1 -s'. '
}



separatorify() {
    if [ "$has_separators" = true ]; then
        last_emoji=""
        while IFS= read -r line; do
            if [[ "$line" =~ ([0-9]+(\.[0-9]+)?)/10 ]]; then
                score="${BASH_REMATCH[1]}"
            else
                continue
            fi

            [[ -z "$score" ]] && continue

            if [[ "$score" == *.* ]]; then
                score_no_dot="${score/./}"    # 9.5 -> 95
            else
                score_no_dot="${score}0"      # 9 -> 90
            fi

            [[ "$score_no_dot" =~ ^[0-9]+$ ]] || continue

            intscore=$((score_no_dot))

            # set current emoji
            if (( intscore < 25 )); then
                current_emoji=":x:"
            elif (( intscore < 45 )); then
                current_emoji=":-1:"
            elif (( intscore < 60 )); then
                current_emoji=":shrug:"
            elif (( intscore < 80 )); then
                current_emoji=":+1:"
            elif (( intscore == 100 )); then
                current_emoji=":star:"
            else
                current_emoji=":heart_eyes:"
            fi


            # only display emoji if different from last one
            if [[ "$current_emoji" != "$last_emoji" ]]; then
                echo -=-= "$current_emoji" =-=-
                last_emoji="$current_emoji"
            fi

            echo "$line"
        done
    else
        cat
    fi
}

avgcalc() {
    awk -F'\\|' '
    {
        rating_part = $2
        gsub(/^[ \t]+/, "", rating_part)

        split(rating_part, parts, "-")
        gsub(/^[ \t]+|[ \t]+$/, "", parts[1])

        if (match(parts[1], /^([0-9]+(\.[0-9])?)\/([0-9]+)$/, m)) {
            rating = m[1] + 0
            scale  = m[3]
            if (scale == 10) {
                sum += rating
                count++
            }
        }
    }
    END {
        avg = sum / count
        printf "### Average monthly score: %.1f/10\n", avg
    }'
}

##########################
##### THE ACTUAL PROGRAM THAT DOES THE PROGRAM STUFF

if [ $has_recover == false ]; then
    $clip_paste | lnend | parse_wanted_cols | filter_out_ep | emojify | sed 's/ | /, /g' | format_into_song > editing_ranking.temp
fi

## gives an error if the file is filled with meaningless clutter
if [ $(grep ':WhiteCircle:.  -  |' < editing_ranking.temp| wc -l) -ne 0 ]; then
    echo 'error, invalid values provided.'
    exit 1
else
    nano editing_ranking.temp
    {
        echo "$title"
        echo "$subtitle"
        afterformat < editing_ranking.temp | separatorify
        avgcalc < editing_ranking.temp
    } | backtodos > rankoutput.txt
fi

if [[ $has_copy == true ]]; then
    $clip_copy < rankoutput.txt
fi
if [[ $has_display == true ]]; then
    cat rankoutput.txt
fi
if [[ $has_display_less == true ]]; then
    less rankoutput.txt
fi

if [ -s errors.txt ]; then
    printf "The ranking has some errors, please double check them to make sure everything is properly done.\nplease run rkf --errors, or rkf --copyerrors"
fi
